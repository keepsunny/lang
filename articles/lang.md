Overview of some programming languages
==========

## Intro

本来只打算把这个东西作为给很多人引入Objective-C的一个东西，但一不小心写多了，然后就成了酱紫了。

## C

C语言的能力完全被国内的高校弱化了，并不是一个简单的结构化的面向过程的程序设计语言，但国内的普遍用的“C语言程序设计”教材都仅仅提供了一些简单的面向过程的结构化程序设计思想而已。

但这反倒让很多人认为C就是那么废物，然后就以为他们学了一个没用的东西，这样子就直接的造成了两方面的问题：第一，C语言的能力被弱化；第二，由于重语言而轻思想，导致课程加长而内容乏味，反而带来了很多负面结果。

C语言不只是一门简简单单的过程式语言，弱类型和指针这两个特性能够让它可以实现多态/继承等OO特性（早期的C++，又叫C with classes，就是利用这个特性来提供一个预编译器来实现C++的OO功能的），特别是函数指针的加入，使得函数能够作为值（当然是有类型的）来自然传递：这样子又一定程度上符合函数式的某些风格。所以，C的强大导致了至今仍然活跃而经久不衰的原因，而且由于和硬件/操作系统结合紧密，所以底层应用绝对少不了他的身影。

## C++

C++虽然和C同出一源（贝尔实验室），而且就是在C语言上进行的一个面向对象的扩展，但是为了兼容和扩展，C++不得不设计的十分复杂来适应各种情况。这样子他所支持的C语言的特性几乎就是很小的一部分了。同样继承了C语言的弱类型机制却没有比较好的利用，反倒是通过把模板机制的引入使得有了一套比较稳定易用的元编程系统。

另外，由于C++既兼有高级语言的特性，又能够像C语言一样切入底层，而且还可以通过模板来进行语言特性级的扩展（比如创建DSL等等），让C++在某段时期曾经辉煌了很久。但新标准姗姗来迟，而且复杂度又在不断的加深，特别是被后继者Java和C#在应用领域的赶超。C++11出现确实给C++的扩展带来了很大的提升，如果能够被比较好的接受的话，很可能会迎来第二个春天。

## Java

对Java的主观偏见就很多。

首先是强类型语言，这就意味着至少运行时的某些动态特性难以实现；但令人纠结的是他还是动态语言，这就意味着他多少还能有一些动态特性让C/C++望尘莫及（至少原生的语言是这样子的，但还好C++能够有很多的扩展特性，比如Boost和Qt）。

Java引入了一个还算是比较完整的对象模型，可是处于妥协还是弄得很纠结：比如，对POD（POJO）的保留会使很多操作要分别来处理（后来才加入了装箱等解决方案），还有虽然有Class类但是显式声明的类并不是第一类对象，并且对OO的畸形支持让他任何事情都不得不变成一个class来处理，让第一类值函数的情况也破灭，然后陷入无限的OO怪圈里面。

另外，作为一个Java黑，我不得不提一下特别重点的一个问题：对于一个动态语言，至少是显式标出的自己是动态语言的语言，居然没有REPL，不觉得很不可思议么？

## Objective-C

C++已经长得够不像C的了，但这一个C的后继，更是颠覆了大家的三观。Alan Kay用儿童的思维造就了Smalltalk这么奇葩的一门程序设计语言，然后被Objective-C拿过来就用了。

Objective-C借用了Smalltalk的对象模型和对象机制，比之于C++的C with classes不同，他的面向对象更纯粹,应该叫C with objects，而且后期又把Smalltalk的代码块机制引入进来，使其有了类似第一类值函数的东西，更为程序设计方法提供了更多方便的支持。而这也成为了来自C/C++及Java界的程序员入手Objective-C比较困难的原因之一。

Objective-C给C带来的是Smalltalk的对象机制，而同样，为了在开发和执行效率方面做一个折中，为其中的Smalltalk方面内容带去了类型约束。这样一来，开发上面能够更方便，而且性能上也不会有过多的缺失，能够做到比较好的互补。

不过Objective-C同样是有缺陷的。平台的封闭导致了除了NextSTEP的后续平台（Mac OS X、iOS、OpenStep/GNUStep）外几乎没有什么其他的应用范围。GCC套对Objective-C有不错的支持，但少了NS基础库使得几乎没有可用性。如果能够及时的解决这个问题的话，倒是有可能更好的进行推广适用。

## Perl

Perl的第一原则是TMTOWTDI（做事情的方法不止一种）。而早期就成了一个各种语言的组合体：从C语言和shell里汲取了多处特性，又合并了sed/awk的功能。早期的Perl也许就是一个类shell的替代语言，但是，发展方向决定了shell没能被淘汰或者被替换掉，而是让Perl变得更为强大更为General-Purpose。

这样看其实Perl也算是C的一个后裔，不过血缘关系浅了些。只有部分形式上还有C语言的一些痕迹和继承来的部分似是而非的特性，跟C++不同的是，Perl的特性加上去的看起来有些混乱，看起来好像没有什么原则（相反C++的原则性好象又太强了，以至于标注出台的如此纠结）。可是Perl的原则又是很明显的，所以才会把能够方便能够实现quick & dirty的目的的内容都尽量给加了上来。所以这样一来，Perl可以很简单很强大，同时Perl又可以很复杂很纠结，你能想到他是什么样子的，他就是什么样子的。

但这不是Perl的一切。

Larry Wall（Perl的创始人）是个语言学家（`Linguist`，通常意义上的语言学），于是，他创造了自己的语言。然后，其他的天才也开始被影响了，GVR（Python）、Matz（Ruby）等等，直到现在这些人和这些语言仍在社区和企业作为热门或者新兴的技术来被使用。

Perl对其他方面影响也很广，PHP也几乎能被看成一个被阉割了的Perl，而早期的Ruby甚至就是一个Matz的Perl实现。CPAN是一个很成功的包管理系统，而Perl强大的测试体系也给软件开发过程带来了很大的改善。尽管现在Perl已经渐渐淡出了，但他仍然以某种形式在默默的做着贡献。

## Reference

  * 维基百科
  * 《深入探索C++对象模型》
  * 《C++语言的设计和演化》
  * 《Qt Reference Manual》
  * 《松本行弘的编程世界》
  * 《奇思妙想：15位伟大的计算机学家及其发现》
  * 《Mastermind of Programming》（中文名《编程之魂》）
  * 《Ruby Best Pratices》
  * 《JavaScript语言精髓与编程实践》
